# 算法🌩

## 基础排序

## 堆实现

## 链表

## 前缀树

## 二叉树

## Ez 贪心

## 并查集

## 图

## Ez 动态规划

## 滑动时间窗口

一个双向队列，小的最在最前面，⚠️存的是下标！

新来了数字 5，此时队列里已经存在：1、3、8、9，就需要 pollLast()  8、9，然后 addLast（5的下标）

要考虑窗口的大小，超过大小后每次需要 pollFirst()

如何判断超出容量？ 当前来到了 cur 下标，if window.peekFirst == cur - windowSize  -> 证明刚刚超出，需要 pollFirst

### 加油站


> 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
>
> 说明: 如果题目有解，该答案即为唯一答案。输入数组均为非空数组，且长度相同。输入数组中的元素均为非负数。
>
> ```java
> int canCompleteCircuit(int[] gas, int[] cost) 
> ```

1. 生成 gas[i] - cost[i] 数组 - myGas，用来判断能否达到下一个加油站
2. 用 myGas 生成数组累加和 - myGasPre （⚠️长度为 myGas 的 2 倍）
   1. 因为这样可以方便得出，从每个位置出发的累加和数组
3. 根据前缀累加和，使用滑动时间窗口判断有没有复数（窗口大小为 myGas 数组大小）
4. 核心思想：遍历每一个出发的位置，如果累加和的最小值不是负数则返回该位置，如果最小值是负数，证明中途有位置拉胯，所以从该位置出发是无效的

### 理想的字数组

> 给定一个整型数组arr，和一个整数num
>
> 某个arr中的子数组sub，如果想达标，必须满足：sub中最大值 – sub中最小值 <= num，
>
> 返回arr中达标子数组的数量
>
> ```java
> int num(int[] arr, int sum)
> ```

1. 两个滑动窗口 - max、min，窗口的左右指针 - l、r
1. 从 0～length，遍历作为 l
1. 固定l，扩容窗口，sub中最大值 – sub中最小值 > num 退出窗口扩容
1. count += r - l + 1
1. 去下一个位置当 l

### 滑动数组中的最大值

> 窗口内最大值或最小值更新结构的实现
>
> 假设一个固定大小为W的窗口，依次划过arr，
>
> 返回每一次滑出状况的最大值
>
> 例如，arr = [4,3,5,4,3,3,6,7], W = 3
>
> 返回：[5,5,5,4,6,7]
>
> ```java
> int[] getMaxWindow(int[] arr, int w)
> ```

1. 准备滑动窗口 max
2. 直接开始遍历去添加
3. 超过容量时移除
4. 下标到达 size 的时候 res[index++] = arr[win.peekFirst()]

### 滑动窗口对动态规划的优化

> 体现在斜率优化的时候，格子的依赖性质
>
> arr是货币数组，其中的值都是正数。再给定一个正数aim。
>
> 每个值都认为是一张货币，
>
> 返回组成aim的最少货币数
>
> 注意：因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了
>
> ```java
> int dp(int[] arr, int aim)
> ```

1. 写出暴力尝试
2. 改成 dp
3. 繁琐的 滑动时间窗口 优化，建议参考代码

## 单调栈

单调栈会反回一个二维数组，（内部使用栈实现，小的数影响范围最广 - 》在栈中存活时间最长，木桶原理的感觉🪵）

第一维度代表原先数组的数字下标，

第二维度只有两个数，0 位置存储的是 左侧比他小离他最近的（原数组下标），1位置存储的是 右侧比他小离他最近的（原数组下标）

### 单调栈的实现

> 使用栈实现，人为保证栈底到栈顶的数据由小到大，意思就是说栈中越 poll() 越小
>
> 每次数据弹出都能填写两个位置的值
>
> pop = stack.pop() , pop 左侧比他小的理他最近的就是，stack.peek()，右侧则是 将要进栈的数字
>
> ```java
> int[][] monotonous(int[] arr)
> ```

1. 遍历 arr，准备压栈位置 i
   1. 如果栈顶的数大于位置 i 的数，弹出 pop
   2. 填写返回数组，pop 0 为该位置 pop 后的 peek（栈顶的下一个），pop 1 为 i
2. i 位置压栈，接着遍历
3. 数组遍历完毕，此时需要处理栈中的残余
4. 栈疯狂 pop，在栈中的位置的右侧找不到比他小的了，所以 pop 右侧明显应该为 -1，左侧即为 pop 该位置 pop 后的 peek（栈顶的下一个）
5. 栈 pop 完毕，注意此时栈底位置，左侧右侧都找不到比他小的，所以都填写 -1

### 支持重复的单调栈的实现

1. 准备一个栈，栈中存的是链表
2. 遍历 arr，准备压栈位置 i
   1. 如果栈顶的数大于位置 i 的数 (基础判断不谈了)，弹出 popList，遍历 Integer pop : popList
   2. 填写返回数组，pop 0 为该位置 pop 后的 peek（栈顶的下一个），pop 1 为 i
3. i 位置准备压栈，判断栈中是否为空，不为空 peek 下链表中的位置对应数字是否与 i 对应的相同
   1. 如果相同：i 直接接在链表后面
   2. 如果不同：new List（），i 接在 new 出的链表后面
4. 数组遍历完毕，此时需要处理栈中的残余
5. 栈疯狂 popList = stack.pop()，Integer pop : popList
6. pop 在栈中的位置的右侧找不到比他小的了，所以 pop 右侧明显应该为 -1，左侧即为 pop 该位置 pop 后的 peek（栈顶的下一个）
7. 栈 pop 完毕，注意此时栈底位置，左侧右侧都找不到比他小的，所以都填写 -1

### 特殊子数组

> 给定一个只包含正数的数组arr，arr中任何一个子数组sub，
> 一定都可以算出(sub累加和 )* (sub中的最小值)是什么，
> 那么所有子数组中，这个值最大是多少？
>
> ```java
> int max1(int[] arr)
> ```

1. 重要思路：index 遍历所有位置，分析当 index 作为数组最小值时，最大累加和是多少
2. 使用单调栈，求出每个位置作为最小值时的左边界和右边界
3. 生成前缀和数组
4. 借助 前缀和数组 + 单调栈 遍历一遍数组即可得到答案

### 长方形的面积

> [leecode链接](https://leetcode.com/problems/largest-rectangle-in-histogram)
>
> 给定一个非负数组arr，代表直方图，返回直方图的最大长方形面积
>
> ```java
> int largestRectangleArea1(int[] height) 
> ```

1. 重要思路：index 遍历所有位置，分析当 index 作为矩形的最短遍时，面积是多少
2. 使用单调栈，求出每个位置作为最小值时的左边界和右边界
3. 遍历一遍数组，借助单调栈信息，即可得到答案

### 由字符 1 组成的长方形面积

> [leecode链接](https://leetcode.com/problems/maximal-rectangle/)
>
> 给定一个二维数组matrix，其中的值不是0就是1，返回全部由1组成的最大子矩形内部有多少个1（面积）
>
> ```java
> int maximalRectangle(char[][] map)
> ```

1. 重要思路：数组压缩，遍历每一行，再遍历每一列，把当列的连续的 1 压缩下来
2. 数组压缩后，
3. 当遍历每一列，求长方形的面积
4. 找出最大值完事了

### 由字符 1 组成的长方形数量

> [leecode链接](https://leetcode.com/problems/count-submatrices-with-all-ones)
>
> 给定一个二维数组matrix，其中的值不是0就是1，返回全部由1组成的子矩形数量
>
> ```java
> int numSubmat(int[][] mat)
> ```

1. 和求面积极其相似
2. 在弹出时，由求面积最大值，改为了累加 必须包含弹出为最低边时的矩形数量
   1. 为什么 包含弹出为最低边时的矩形数量 可以全部求到？
      - 因为数组是从 1 开始累加的，假设一个位置累加到了高度为 3，呢我们一定遍历过了高度为 2、1 的时候
   2. 包含弹出为边时的矩形数量的公式
      - `height * （width * （width+1）/ 2）`

### 所有子数组最小值的累加和

> [Leetcode](https://leetcode.com/problems/sum-of-subarray-minimums/)
>
> 给定一个数组arr，返回所有子数组最小值的累加和
>
> ```java
> int subArrayMinSum(int[] arr)
> ```

1. 重要思路：以当前位置作为最小值的子数组有多少个
2. 用单调栈生成辅助数组
3. 遍历辅助数组，可以得到以每个位置作为最小值的范围是多少
   - `（index - 左边界）*（右边界 - index）` 即可以求出子数组有多少个
   - 个数乘以最小值，也就是 个数 * arr[index]，每个位置这么求，累加起来就是答案

## 斐波那契数列

## KMP

## Manacher

## BFPRT

## 蓄水池

## Morris 遍历

## 线段树

## IndexTree

## AC 自动机

## Hash

## 资源限制

## AVL

## SBTree

## Skip

## Tables 应用

## 根据规则猜解法

## 卡特兰数

## 宏观 Coding

## 四边形不等式

## DC3

## 外部信息简化

## 网络流
