# 算法🌩

## 基础排序

## 堆实现

## 链表

## 前缀树

## 二叉树

## Ez 贪心

## 并查集

## 图

## Ez 动态规划

## 滑动时间窗口

一个双向队列，小的最在最前面，⚠️存的是下标！

新来了数字 5，此时队列里已经存在：1、3、8、9，就需要 pollLast()  8、9，然后 addLast（5的下标）

要考虑窗口的大小，超过大小后每次需要 pollFirst()

如何判断超出容量？ 当前来到了 cur 下标，if window.peekFirst == cur - windowSize  -> 证明刚刚超出，需要 pollFirst

### 加油站


> 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
>
> 说明: 如果题目有解，该答案即为唯一答案。输入数组均为非空数组，且长度相同。输入数组中的元素均为非负数。
>
> ```java
> int canCompleteCircuit(int[] gas, int[] cost) 
> ```

1. 生成 gas[i] - cost[i] 数组 - myGas，用来判断能否达到下一个加油站
2. 用 myGas 生成数组累加和 - myGasPre （⚠️长度为 myGas 的 2 倍）
   1. 因为这样可以方便得出，从每个位置出发的累加和数组
3. 根据前缀累加和，使用滑动时间窗口判断有没有复数（窗口大小为 myGas 数组大小）
4. 核心思想：遍历每一个出发的位置，如果累加和的最小值不是负数则返回该位置，如果最小值是负数，证明中途有位置拉胯，所以从该位置出发是无效的

### 理想的字数组

> 给定一个整型数组arr，和一个整数num
>
> 某个arr中的子数组sub，如果想达标，必须满足：sub中最大值 – sub中最小值 <= num，
>
> 返回arr中达标子数组的数量
>
> ```java
> int num(int[] arr, int sum)
> ```

1. 两个滑动窗口 - max、min，窗口的左右指针 - l、r
1. 从 0～length，遍历作为 l
1. 固定l，扩容窗口，sub中最大值 – sub中最小值 > num 退出窗口扩容
1. count += r - l + 1
1. 去下一个位置当 l

### 滑动数组中的最大值

> 窗口内最大值或最小值更新结构的实现
>
> 假设一个固定大小为W的窗口，依次划过arr，
>
> 返回每一次滑出状况的最大值
>
> 例如，arr = [4,3,5,4,3,3,6,7], W = 3
>
> 返回：[5,5,5,4,6,7]
>
> ```java
> int[] getMaxWindow(int[] arr, int w)
> ```

1. 准备滑动窗口 max
2. 直接开始遍历去添加
3. 超过容量时移除
4. 下标到达 size 的时候 res[index++] = arr[win.peekFirst()]

### 滑动窗口对动态规划的优化

> 体现在斜率优化的时候，格子的依赖性质
>
> arr是货币数组，其中的值都是正数。再给定一个正数aim。
>
> 每个值都认为是一张货币，
>
> 返回组成aim的最少货币数
>
> 注意：因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了
>
> ```java
> int dp(int[] arr, int aim)
> ```

1. 写出暴力尝试
2. 改成 dp
3. 繁琐的 滑动时间窗口 优化，建议参考代码

## 单调栈

单调栈会反回一个二维数组，（内部使用栈实现，小的数影响范围最广 - 》在栈中存活时间最长，木桶原理的感觉🪵）

第一维度代表原先数组的数字下标，

第二维度只有两个数，0 位置存储的是 左侧比他小离他最近的（原数组下标），1位置存储的是 右侧比他小离他最近的（原数组下标）

### 单调栈的实现

> 使用栈实现，人为保证栈底到栈顶的数据由小到大，意思就是说栈中越 poll() 越小
>
> 每次数据弹出都能填写两个位置的值
>
> pop = stack.pop() , pop 左侧比他小的理他最近的就是，stack.peek()，右侧则是 将要进栈的数字
>
> ```java
> int[][] monotonous(int[] arr)
> ```

1. 遍历 arr，准备压栈位置 i
   1. 如果栈顶的数大于位置 i 的数，弹出 pop
   2. 填写返回数组，pop 0 为该位置 pop 后的 peek（栈顶的下一个），pop 1 为 i
2. i 位置压栈，接着遍历
3. 数组遍历完毕，此时需要处理栈中的残余
4. 栈疯狂 pop，在栈中的位置的右侧找不到比他小的了，所以 pop 右侧明显应该为 -1，左侧即为 pop 该位置 pop 后的 peek（栈顶的下一个）
5. 栈 pop 完毕，注意此时栈底位置，左侧右侧都找不到比他小的，所以都填写 -1

### 支持重复的单调栈的实现

1. 准备一个栈，栈中存的是链表
2. 遍历 arr，准备压栈位置 i
   1. 如果栈顶的数大于位置 i 的数 (基础判断不谈了)，弹出 popList，遍历 Integer pop : popList
   2. 填写返回数组，pop 0 为该位置 pop 后的 peek（栈顶的下一个），pop 1 为 i
3. i 位置准备压栈，判断栈中是否为空，不为空 peek 下链表中的位置对应数字是否与 i 对应的相同
   1. 如果相同：i 直接接在链表后面
   2. 如果不同：new List（），i 接在 new 出的链表后面
4. 数组遍历完毕，此时需要处理栈中的残余
5. 栈疯狂 popList = stack.pop()，Integer pop : popList
6. pop 在栈中的位置的右侧找不到比他小的了，所以 pop 右侧明显应该为 -1，左侧即为 pop 该位置 pop 后的 peek（栈顶的下一个）
7. 栈 pop 完毕，注意此时栈底位置，左侧右侧都找不到比他小的，所以都填写 -1

## 斐波那契数列

## KMP

## Manacher

## BFPRT

## 蓄水池

## Morris 遍历

## 线段树

## IndexTree

## AC 自动机

## Hash

## 资源限制

## AVL

## SBTree

## Skip

## Tables 应用

## 根据规则猜解法

## 卡特兰数

## 宏观 Coding

## 四边形不等式

## DC3

## 外部信息简化

## 网络流
