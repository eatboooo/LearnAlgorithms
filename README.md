# 算法🌩

## 基础排序

## 堆实现

## 链表

## 前缀树

## 二叉树

## Ez 贪心

## 并查集

## 图

## Ez 动态规划

## 滑动时间窗口

一个双向队列，小的最在最前面，⚠️存的是下标！

新来了数字 5，此时队列里已经存在：1、3、8、9，就需要 pollLast()  8、9，然后 addLast（5的下标）

要考虑窗口的大小，超过大小后每次需要 pollFirst()

如何判断超出容量？ 当前来到了 cur 下标，if window.peekFirst == cur - windowSize  -> 证明刚刚超出，需要 pollFirst

### 加油站


> 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
>
> 说明: 如果题目有解，该答案即为唯一答案。输入数组均为非空数组，且长度相同。输入数组中的元素均为非负数。
>
> ```java
> int canCompleteCircuit(int[] gas, int[] cost) 
> ```

1. 生成 gas[i] - cost[i] 数组 - myGas，用来判断能否达到下一个加油站
2. 用 myGas 生成数组累加和 - myGasPre （⚠️长度为 myGas 的 2 倍）
    1. 因为这样可以方便得出，从每个位置出发的累加和数组
3. 根据前缀累加和，使用滑动时间窗口判断有没有复数（窗口大小为 myGas 数组大小）
4. 核心思想：遍历每一个出发的位置，如果累加和的最小值不是负数则返回该位置，如果最小值是负数，证明中途有位置拉胯，所以从该位置出发是无效的

### 理想的字数组

> 给定一个整型数组arr，和一个整数num
>
> 某个arr中的子数组sub，如果想达标，必须满足：sub中最大值 – sub中最小值 <= num，
>
> 返回arr中达标子数组的数量
>
> ```java
> int num(int[] arr, int sum)
> ```

1. 两个滑动窗口 - max、min，窗口的左右指针 - l、r
1. 从 0～length，遍历作为 l
1. 固定l，扩容窗口，sub中最大值 – sub中最小值 > num 退出窗口扩容
1. count += r - l + 1
1. 去下一个位置当 l

### 滑动数组中的最大值

> 窗口内最大值或最小值更新结构的实现
>
> 假设一个固定大小为W的窗口，依次划过arr，
>
> 返回每一次滑出状况的最大值
>
> 例如，arr = [4,3,5,4,3,3,6,7], W = 3
>
> 返回：[5,5,5,4,6,7]
>
> ```java
> int[] getMaxWindow(int[] arr, int w)
> ```

1. 准备滑动窗口 max
2. 直接开始遍历去添加
3. 超过容量时移除
4. 下标到达 size 的时候 res[index++] = arr[win.peekFirst()]

### 滑动窗口对动态规划的优化

> 体现在斜率优化的时候，格子的依赖性质
>
> arr是货币数组，其中的值都是正数。再给定一个正数aim。
>
> 每个值都认为是一张货币，
>
> 返回组成aim的最少货币数
>
> 注意：因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了
>
> ```java
> int dp(int[] arr, int aim)
> ```

1. 写出暴力尝试
2. 改成 dp
3. 繁琐的 滑动时间窗口 优化，建议参考代码

## 单调栈

单调栈会反回一个二维数组，（内部使用栈实现，小的数影响范围最广 - 》在栈中存活时间最长，木桶原理的感觉🪵）

第一维度代表原先数组的数字下标，

第二维度只有两个数，0 位置存储的是 左侧比他小离他最近的（原数组下标），1位置存储的是 右侧比他小离他最近的（原数组下标）

### 单调栈的实现

> 使用栈实现，人为保证栈底到栈顶的数据由小到大，意思就是说栈中越 poll() 越小
>
> 每次数据弹出都能填写两个位置的值
>
> pop = stack.pop() , pop 左侧比他小的理他最近的就是，stack.peek()，右侧则是 将要进栈的数字
>
> ```java
> int[][] monotonous(int[] arr)
> ```

1. 遍历 arr，准备压栈位置 i
    1. 如果栈顶的数大于位置 i 的数，弹出 pop
    2. 填写返回数组，pop 0 为该位置 pop 后的 peek（栈顶的下一个），pop 1 为 i
2. i 位置压栈，接着遍历
3. 数组遍历完毕，此时需要处理栈中的残余
4. 栈疯狂 pop，在栈中的位置的右侧找不到比他小的了，所以 pop 右侧明显应该为 -1，左侧即为 pop 该位置 pop 后的 peek（栈顶的下一个）
5. 栈 pop 完毕，注意此时栈底位置，左侧右侧都找不到比他小的，所以都填写 -1

### 支持重复的单调栈的实现

1. 准备一个栈，栈中存的是链表
2. 遍历 arr，准备压栈位置 i
    1. 如果栈顶的数大于位置 i 的数 (基础判断不谈了)，弹出 popList，遍历 Integer pop : popList
    2. 填写返回数组，pop 0 为该位置 pop 后的 peek（栈顶的下一个），pop 1 为 i
3. i 位置准备压栈，判断栈中是否为空，不为空 peek 下链表中的位置对应数字是否与 i 对应的相同
    1. 如果相同：i 直接接在链表后面
    2. 如果不同：new List（），i 接在 new 出的链表后面
4. 数组遍历完毕，此时需要处理栈中的残余
5. 栈疯狂 popList = stack.pop()，Integer pop : popList
6. pop 在栈中的位置的右侧找不到比他小的了，所以 pop 右侧明显应该为 -1，左侧即为 pop 该位置 pop 后的 peek（栈顶的下一个）
7. 栈 pop 完毕，注意此时栈底位置，左侧右侧都找不到比他小的，所以都填写 -1

### 特殊子数组

> 给定一个只包含正数的数组arr，arr中任何一个子数组sub，
> 一定都可以算出(sub累加和 )* (sub中的最小值)是什么，
> 那么所有子数组中，这个值最大是多少？
>
> ```java
> int max1(int[] arr)
> ```

1. 重要思路：index 遍历所有位置，分析当 index 作为数组最小值时，最大累加和是多少
2. 使用单调栈，求出每个位置作为最小值时的左边界和右边界
3. 生成前缀和数组
4. 借助 前缀和数组 + 单调栈 遍历一遍数组即可得到答案

### 长方形的面积

> [leecode链接](https://leetcode.com/problems/largest-rectangle-in-histogram)
>
> 给定一个非负数组arr，代表直方图，返回直方图的最大长方形面积
>
> ```java
> int largestRectangleArea1(int[] height) 
> ```

1. 重要思路：index 遍历所有位置，分析当 index 作为矩形的最短遍时，面积是多少
2. 使用单调栈，求出每个位置作为最小值时的左边界和右边界
3. 遍历一遍数组，借助单调栈信息，即可得到答案

### 由字符 1 组成的长方形面积

> [leecode链接](https://leetcode.com/problems/maximal-rectangle/)
>
> 给定一个二维数组matrix，其中的值不是0就是1，返回全部由1组成的最大子矩形内部有多少个1（面积）
>
> ```java
> int maximalRectangle(char[][] map)
> ```

1. 重要思路：数组压缩，遍历每一行，再遍历每一列，把当列的连续的 1 压缩下来
2. 数组压缩后，
3. 当遍历每一列，求长方形的面积
4. 找出最大值完事了

### 由字符 1 组成的长方形数量

> [leecode链接](https://leetcode.com/problems/count-submatrices-with-all-ones)
>
> 给定一个二维数组matrix，其中的值不是0就是1，返回全部由1组成的子矩形数量
>
> ```java
> int numSubmat(int[][] mat)
> ```

1. 和求面积极其相似
2. 在弹出时，由求面积最大值，改为了累加 必须包含弹出为最低边时的矩形数量
    1. 为什么 包含弹出为最低边时的矩形数量 可以全部求到？
        - 因为数组是从 1 开始累加的，假设一个位置累加到了高度为 3，呢我们一定遍历过了高度为 2、1 的时候
    2. 包含弹出为边时的矩形数量的公式
        - `height * （width * （width+1）/ 2）`

### 所有子数组最小值的累加和

> [Leetcode](https://leetcode.com/problems/sum-of-subarray-minimums/)
>
> 给定一个数组arr，返回所有子数组最小值的累加和
>
> ```java
> int subArrayMinSum(int[] arr)
> ```

1. 重要思路：以当前位置作为最小值的子数组有多少个
2. 用单调栈生成辅助数组
3. 遍历辅助数组，可以得到以每个位置作为最小值的范围是多少
    - `（index - 左边界）*（右边界 - index）` 即可以求出子数组有多少个
    - 个数乘以最小值，也就是 个数 * arr[index]，每个位置这么求，累加起来就是答案

## 斐波那契数列

## KMP

kmp 算法据说是需要掌握到被火车撞了躺在地上也可以立马写出来的程度

查询 s2 在 s1 中出现的位置，也就是 s1.indexOf(s2)

### 基础实现

- 关键数组 nextArr
    - 默认 0 位置填 -1，1位置填 0
    - nextArr[i] 代表：必须以 i 位置的字符结尾的前提下的字符串，与从 0 位置开始的字符串，最长公共串的大小是多少
    - ![例子](https://tva3.sinaimg.cn/mw690/6ca62763gy1gztalpjpsnj20wu03qdgc.jpg)
    - nextArr 高效得到是关键（利用上一个位置得到的结论去加速）
        - 假设此时来到 i 位置，同时有变量 compare = nextArr[i-1] + 1
        - 当 i < char.length 时开循环
        - 如果 char[i] == char[compare]，此时经过思考，证明 nextArr[i] = nextArr[i-1]+1，也就是 nextArr[i++] = ++compare,即可以复用前面的数据
        - 如果 char[i] ！= char[compare] && compare > 0，compare = nextArr[compare] ，再去比较是否相同
            - ⚠️为什么 compare = nextArr[compare] ，而不是从 0 开始？
                - compare = nextArr[compare] 的本质其实是，
                - 我们好不容易从 0 开始比较到了 compare 位置，发现有一个位置对不上了，我们能不能不从 0 + 1 的位置再开始比较，能否利用之前的信息，
                - 而 nextArr [compare] 的值的含义就是 以 compare 结尾的，与 0 位置开头的相同字符串的长度是多少，
                - 这样我们直接跳到相同字母的后面再开始比较，
                - 相当于nextArr 数组记录了我们提前比较过的数据，进行一个加速
        - 此时 comare == 0 成立，真就没有比得过的, nextArr[i++] = 0
        - 结束循环
- 生成了关键的 nextArr 之后，一切变得简单
    - 两个指针分别对应 s1,s2
    - 遍历比较
    - 当出现不同字符时，s2index 不要归零，s2index = nextArr[s2index] （ nextArr == -1 情况除外）
    - 一直找下去...

### 判断str1和str2是否互为旋转字符串

- 旋转字符串是什么？
    - abcdefg、cdefgab 互为旋转字符串
    - defgabc、abcdefg 互为旋转字符串
    - abc ｜ defg  中间切一刀，两边互换位置则是旋转字符串
    - 所以有 ：如果 str2 是 str1 + str1 的子字符串的话，则str1和str2互为旋转字符串
    - 调用 indexOf，本质上就是 kmp 算法，可以得到答案

### 是否为子树

> 给定两棵二叉树的头节点head1和head2，
>
> 返回head1中是否有某个子树的结构和head2完全一样

1. 使用先序遍历序列化两棵树，得到两个字符串
2. 查看两个字符串是否一个字符串为另一个字符串的子串

## Manacher

## BFPRT

## 蓄水池

## Morris 遍历

## 线段树

## IndexTree

## AC 自动机

## Hash

## 资源限制

## AVL

## SBTree

## Skip

## Tables 应用

## 根据规则猜解法

## 卡特兰数

## 宏观 Coding

## 四边形不等式

## DC3

## 外部信息简化

## 网络流

